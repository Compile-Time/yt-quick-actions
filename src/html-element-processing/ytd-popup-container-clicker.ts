import { buffer, debounceTime, first, Subject } from "rxjs";
import { MutationsElementExtractor } from "../mutations/mutations-element-extractor";
import { OneshotObserver } from "../observation/observer-types";
import { OneshotObserverId } from "../enums/oneshot-observer-id";
import {
  SvgDrawPathNavigationFilter,
  TagNavigationFilter,
} from "../html-navigation/filter/navigation-filter";
import { SvgDrawPath, Tags } from "./element-data";
import { MutationSummary } from "mutation-summary";
import { HtmlParentNavigator } from "../html-navigation/html-parent-navigator";
import { HtmlTreeNavigator } from "../html-navigation/html-tree-navigator";

export type SvgOptionFn = (svgOption: HTMLElement) => void;

export class YtdPopupContainerClicker {
  private readonly _oneshotObserver: OneshotObserver;
  private subject = new Subject<MutationsElementExtractor>();

  constructor(
    oneshotObserverId: OneshotObserverId,
    svgToClick: SvgDrawPath,
    ytdPopupContainer: HTMLElement
  ) {
    this._oneshotObserver = this.createOneshotObserver(
      oneshotObserverId,
      svgToClick,
      ytdPopupContainer
    );
  }

  get oneshotObserver() {
    return this._oneshotObserver;
  }

  /**
   * Observe {@link MutationsElementExtractor}s generated by this {@link YtdPopupContainerClicker} with a debounce and buffer
   * them before running any extraction logic on them.
   *
   * This method uses RxJS to facilitate the debounce and buffer behaviour. The reason and use case for this
   * method is the following: The `ytd-popup-container` keeps as many `ytd-menu-service-item-renderer` elements
   * around as are needed for the current page. However, the behaviour for this functionality is interesting:
   * - If a page needs more `ytd-menu-service-item-renderer` elements, existing entries are hidden, new hidden
   * entries are added then all entries are made visible.
   * - If a page needs less, all entries are hidden, the unneeded entries are removed and then all are made visible.
   * - If a page does not need more or less entries but the actions themselves change, all
   * `ytd-menu-service-item-renderer` elements are hidden, then the contained SVG of
   * some of the `ytd-menu-service-item-renderer` elements is changed and then the elements are un-hidden.
   *
   * Therefore, it is not enough to check for the visibility of a `ytd-menu-service-item-renderer` element because
   * its contained SVG might change. So a short term buffer is needed which contains all DOM mutation changes in
   * the millisecond range. This buffer can then be checked for the existing of an SVG add mutation.
   *
   * @param clickCallback Optional: Custom callback to run on the found `svgToClick` element instead of calling
   * `HTMLElement.click()` on it.
   */
  observeAndBufferMutationChangesThenClickSvg(
    clickCallback?: SvgOptionFn
  ): void {
    const popupContainer = HtmlTreeNavigator.startFrom(document.body)
      .findFirst(new TagNavigationFilter(Tags.YTD_POPUP_CONTAINER))
      .consume();

    this.subject
      .pipe(buffer(this.subject.pipe(debounceTime(10))), first())
      .subscribe((mutationChanges: MutationsElementExtractor[]) => {
        this.clickEntrySvg(mutationChanges, clickCallback);
        this._oneshotObserver.disconnect();
        popupContainer.removeAttribute("hidden");
      });

    // Hide the popup container so there is no drop-down flicker when triggering a quick action.
    popupContainer.setAttribute("hidden", "");
  }

  /**
   * Click the {@link SvgDrawPath} which was given as a constructor argument to {@link YtdPopupContainerClicker}
   * in the more options popup.
   *
   * This method takes a list of {@link MutationsElementExtractor}s and then extracts the desired SVG element of each change
   * as defined by the constructor's `svgToClick` parameter. Depending on if the SVG was added or
   * un-hidden by the parent `ytd-menu-service-item-renderer` element, the SVG element will be passed to
   * `clickCallback` as is or extracted from the `ytd-menu-service-item-renderer` element.
   *
   * When determining to pass the SVG element as is or to extract it from the `ytd-menu-service-item-renderer`, it
   * is first checked if the SVG element was added and then checked if the parent `ytd-menu-service-item-renderer` was
   * unhidden. This order is important because the parent element is always added before the SVG element.
   *
   * @param mutationChanges List of {@link MutationsElementExtractor}s to process for the click
   * @param clickCallback Optional: Custom callback to run on the found `svgToClick` element instead of calling
   * `HTMLElement.click()` on it.
   */
  private clickEntrySvg(
    mutationChanges: MutationsElementExtractor[],
    clickCallback?: SvgOptionFn
  ): void {
    const addedSvgElements = mutationChanges
      .map((mutationChange) => mutationChange.extractSvgFromAddedMutations())
      .filter((addedSvgElement) => !!addedSvgElement);
    const svgsOfunHiddenYtdMenuServiceItemRenderers = mutationChanges
      .map((mutationChange) =>
        mutationChange.extractSvgFromUnHiddenYtdMenuServiceItemRenderer()
      )
      .filter(
        (unHiddenYtdServiceMenuItemRenderer) =>
          !!unHiddenYtdServiceMenuItemRenderer
      );

    if (addedSvgElements.length === 1) {
      const saveSvg = HtmlParentNavigator.startFrom(addedSvgElements[0])
        .find(new TagNavigationFilter(Tags.TP_YT_PAPER_ITEM))
        .consume();

      if (clickCallback) {
        clickCallback(saveSvg);
      } else {
        saveSvg.click();
      }
    } else if (svgsOfunHiddenYtdMenuServiceItemRenderers.length === 1) {
      const saveSvg = svgsOfunHiddenYtdMenuServiceItemRenderers[0];
      if (clickCallback) {
        clickCallback(svgsOfunHiddenYtdMenuServiceItemRenderers[0]);
      } else {
        saveSvg.click();
      }
    }
  }

  private createOneshotObserver(
    oneshotObserverId: OneshotObserverId,
    svgToClick: SvgDrawPath,
    ytdPopupContainer: Node
  ): OneshotObserver {
    return new OneshotObserver(oneshotObserverId, () => {
      const svgPathFilter = new SvgDrawPathNavigationFilter(svgToClick);
      const summary = new MutationSummary({
        callback: (summaries) =>
          this.subject.next(
            new MutationsElementExtractor(svgPathFilter, summaries)
          ),
        rootNode: ytdPopupContainer,
        queries: [
          { element: `path[d="${SvgDrawPath.VIDEO_SAVE}"]` },
          { attribute: "hidden" },
        ],
      });
      summary.disconnect();
      return summary;
    });
  }
}
